/*********************************************************************
 *
 *  OLED display driver
 *  Module for Microchip TCP/IP Stack
 *   -Provides an API to access an OSD 2864ASWAG01 128x64 pixel OLED
 *    display, using the Sino Wealth SH1101A controller chip
 *   -Reference: None
 *
 *********************************************************************
 * FileName:        OSDOLED.c
 * Dependencies:    TCPIP.h
 * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
 * Compiler:        Microchip C30 v3.12 or higher
 *                  Microchip C18 v3.30 or higher
 * Company:         Microchip Technology, Inc.
 *
 * Software License Agreement
 *
 * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
 * reserved.
 *
 * Microchip licenses to you the right to use, modify, copy, and
 * distribute:
 * (i)  the Software when embedded on a Microchip microcontroller or
 *      digital signal controller product ("Device") which is
 *      integrated into Licensee's product; or
 * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
 *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
 *      used in conjunction with a Microchip ethernet controller for
 *      the sole purpose of interfacing with the ethernet controller.
 *
 * You should refer to the license agreement accompanying this
 * Software for additional information regarding your rights and
 * obligations.
 *
 * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
 * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
 * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
 * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
 * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
 *
 *
 * Author               Date        Comment
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * Rodger Richey        03/10/07    Original
 ********************************************************************/
#include "TCPIP Stack/TCPIP.h"
#include "OLED.h"

//******************************************************************************
//******************************************************************************
// Section: Constants
//******************************************************************************
//******************************************************************************

#define OFFSET 2

//******************************************************************************
//******************************************************************************
// Section: Macros
//******************************************************************************
//******************************************************************************

#define OutputByteToPins(cmd)   {LATE = (LATE & 0xF0) | (cmd & 0x0F); LATF = (LATF & 0x0F) | (cmd & 0xF0);}

//******************************************************************************
//******************************************************************************
// Section: Function Prototypes
//******************************************************************************
//******************************************************************************

unsigned char Convert1xto2x(unsigned char uplow, unsigned char byte);

//******************************************************************************
//******************************************************************************
// Section: Application Callable Functions
//******************************************************************************
//******************************************************************************

void oledFillDisplay(unsigned char data)
{
    unsigned char i,j;

    for(i=0xB0;i<0xB8;i++)          // Go through all 8 pages
    {
        oledWriteCommand(i);        // Set page
        oledWriteCommand(0x00+OFFSET);      // Set lower column address
        oledWriteCommand(0x10);     // Set upper column address
        oledD_C = 1;                // Enable data
        Nop();
        oledCS = 0;                 // Enable display
        for(j=0;j<132u;j++)          // Write to all 132 bytes
        {
            OutputByteToPins(data);
            Nop();                  // 320ns delay
            oledWR = 0;             // Enable writes
            Nop();
            oledWR = 1;             // Disable writes
        }
        Nop();
        oledCS = 1;                 // Disable display
    }
    return;
}

void oledFillLine(unsigned char data, unsigned char line)
{
    unsigned char i,j;

    oledWriteCommand(0xB0+line);// Set page
    oledWriteCommand(0x00+OFFSET);      // Set lower column address
    oledWriteCommand(0x10);     // Set upper column address
    oledD_C = 1;                // Enable data
    Nop();
    oledCS = 0;                 // Enable display
    for(j=0;j<132u;j++)          // Write to all 132 bytes
    {
        OutputByteToPins(data);
        Nop();                  // 320ns delay
        oledWR = 0;             // Enable writes
        Nop();
        oledWR = 1;             // Disable writes
    }
    Nop();
    oledCS = 1;                 // Disable display

    return;
}

void oledInitDisplay(void)
{
    unsigned char i;

// Init LCD
    oledWR = 1;                 // R/W, output, set to 0
    oledWR_TRIS = 0;
    oledCS = 1;                 // CS, output, set to 1
    oledCS_TRIS = 0;
    oledRD = 1;                 // E, output, set to 1
    oledRD_TRIS = 0;
    oledRESET = 0;              // Reset, output set to 0
    oledRESET_TRIS = 0;
    PORTEbits.RE0 = 0;          // D0, output, set to 0
    TRISEbits.TRISE0 = 0;
    PORTEbits.RE1 = 0;          // D1, output, set to 0
    TRISEbits.TRISE1 = 0;
    PORTEbits.RE2 = 0;          // D2, output, set to 0
    TRISEbits.TRISE2 = 0;
    PORTEbits.RE3 = 0;          // D3, output, set to 0
    TRISEbits.TRISE3 = 0;
    PORTFbits.RF4 = 0;          // D4, output, set to 0
    TRISFbits.TRISF4 = 0;
    PORTFbits.RF5 = 0;          // D5, output, set to 0
    TRISFbits.TRISF5 = 0;
    PORTFbits.RF6 = 0;          // D6, output, set to 0
    TRISFbits.TRISF6 = 0;
    PORTFbits.RF7 = 0;          // D7, output, set to 0
    TRISFbits.TRISF7 = 0;
    oledD_C = 0;                // D/C, output, set to 0
    oledD_C_TRIS = 0;
    Delay10KTCYx(63);
    oledRESET = 1;
    Delay10KTCYx(63);

    // Display ON/OFF
    oledWriteCommand(0xAE);     // AF=ON, AE=OFF

    oledFillDisplay(0x00);          // Blank the display

    // VCOMH
    oledWriteCommand(0xDB);     // set VCOMH
    oledWriteCommand(0x23);

    // VP
    oledWriteCommand(0xD9);         // Set VP
    oledWriteCommand(0x22);         // P1=2, P2=2

    // Set DC-DC
    oledWriteCommand(0xAD);     // Set DC-DC
    oledWriteCommand(0x8B);     // 8B=ON, 8A=OFF

    Delay10KTCYx(63);
    // Display ON/OFF
    oledWriteCommand(0xAF);     // AF=ON, AE=OFF


// Init OLED display using SSD1303 driver
    // Display Clock Divide
    oledWriteCommand(0xD5);     // set display clock divide
    oledWriteCommand(0xA0);     // set to 100Hz

    // Display Offset
    oledWriteCommand(0xD3);     // set display offset
    oledWriteCommand(0x00);     // no offset

    // Multiplex Ratio
    oledWriteCommand(0xA8);     // set multiplex ratio
    oledWriteCommand(0x3F);     // set to 64 mux

    // Display Start Line
    oledWriteCommand(0x40);     // Set display start line

    // Re-map
    oledWriteCommand(0xA1);     // [A0]:column address 0 is map to SEG0
                                // [A1]:column address 131 s map to SEG0

    // COM Output Scan Direction
    oledWriteCommand(0xC8);     // C0 is COM0 to COMn, C8 is COMn to COM0

    // COM Pins Hardware Configuration
    oledWriteCommand(0xDA);     // set pins hardware configuration
    oledWriteCommand(0x12);

    // Contrast Control Register
    oledWriteCommand(0x81);     // Set contrast control
    oledWriteCommand(0x60);     // display 0 ~ 127; 2C

    // Entire Display ON/OFF
    oledWriteCommand(0xA4);     // A4=ON

    //Normal or Inverse Display
    oledWriteCommand(0xA6);     // Normal display

    // Lower Column Address
    oledWriteCommand(0x00+OFFSET);      // Set lower column address

    // Higher Column Address
    oledWriteCommand(0x10);     // Set higher column address

    oledFillDisplay(0x00);          // Blank the display

    return;
}

void oledPutImage(rom unsigned char *ptr, unsigned char sizex, unsigned char sizey, unsigned char startx, unsigned char starty)
{
    unsigned char i,j,mask,byte;

    startx += OFFSET;
    for(i=0xB0+starty;i<(0xB0+sizey);i++)
    {
        oledWriteCommand(i);
        oledWriteCommand(startx&0x0F);
        oledWriteCommand(0x10 | ((startx>>4)&0x0F));
        oledD_C = 1;
        Nop();
        oledCS = 0;
        for(j=0;j<sizex;j++)
        {
            byte = *ptr++;
            OutputByteToPins(byte);
            Nop();
            Nop();
            oledWR = 0;
            Nop();
            oledWR = 1;
        }
        Nop();
        oledCS = 1;
    }
    return;
}

void oledPutPixel(unsigned char x,unsigned char y,unsigned char color)
{
    unsigned char lAddr, hAddr, cmd;
    unsigned char temp, mask, display;

    // Assign a page address
         if(y < 8u)  cmd = 0xB0;
    else if(y < 16u) cmd = 0xB1;
    else if(y < 24u) cmd = 0xB2;
    else if(y < 32u) cmd = 0xB3;
    else if(y < 40u) cmd = 0xB4;
    else if(y < 48u) cmd = 0xB5;
    else if(y < 56u) cmd = 0xB6;
    else             cmd = 0xB7;
    oledWriteCommand(cmd);          // Send page command

    // Calculate low and high column addresses
    temp = x + OFFSET;
    lAddr = 0x0F & temp;            // Low address
    hAddr = 0x10 | (temp >> 4);     // High address

    // Calculate mask from rows basically do a y%8 and remainder is bit position
    temp = y>>3;                    // Divide by 8
    temp <<= 3;                     // Multiply by 8
    temp = y - temp;                // Cacluate bit position
    mask = 1 << temp;               // Left shift 1 by bit position

    oledD_C =0;
    Nop();
    oledCS =0;
    Nop();
// Set Column Address low
    OutputByteToPins(lAddr);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

// Set column address high
    OutputByteToPins(hAddr);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

// Read dummy byte
    TRISE |= 0x0F;
    TRISF |= 0xF0;
    oledD_C = 1;
    Nop();
    oledRD = 0;
    Nop();
    oledRD = 1;
    Nop();
// Read data byte
    oledRD = 0;
    Nop();
    display = PORTE & 0x0F;
    display |= PORTF & 0xF0;
    Nop();
    oledRD = 1;
    TRISE &= 0xF0;
    TRISF &= 0x0F;

    if(color)                       // If non-zero for pixel on
        display |= mask;            // or in mask
    else                            // If 0 for pixel off
        display &= ~mask;           // and with inverted mask

    oledD_C = 0;
    Nop();
// Set Column Address low
    OutputByteToPins(lAddr);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

// Set Column Address high
    OutputByteToPins(hAddr);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

// Write Data
    oledD_C = 1;
    Nop();
    OutputByteToPins(display);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;
    Nop();
    oledCS = 1;
    return;
}

void oledPutROMString(rom unsigned char *ptr,unsigned char page, unsigned char col, unsigned char height)
{
    unsigned char i;

    i=col;
    while(*ptr)
    {
        if(height == 1u)
            oledWriteChar1x(*ptr,page,i);
        else if(height == 2u)
            oledWriteChar2x(*ptr,page,i);
        ptr++;
        i+=6;
    }
}

void oledPutString(unsigned char *ptr,unsigned char page, unsigned char col, unsigned char height)
{
    unsigned char i;

    i=col+OFFSET;
    while(*ptr)
    {
        if(height == 1u)
            oledWriteChar1x(*ptr,page,i);
        else if(height == 2u)
            oledWriteChar2x(*ptr,page,i);
        ptr++;
        i+=6;
    }
}

void oledScreenSaver(unsigned char enable)
{
    if(enable == SSON)
    {
        oledWriteCommand(0x26);             // Horizontal Scroll Setup
        oledWriteCommand(0x01);             // Scroll per step 001,010,011,100
        oledWriteCommand(0x00);             // start page address
        oledWriteCommand(0x00);             // 00-12f, 01-64f, 10-128f, 11-256f
        oledWriteCommand(0x07);             // end page address
        oledWriteCommand(0x2F);             // activate horizontal scroll
    }
    else
        oledWriteCommand(0x2E);             // deactivate horizontal scroll
    return;
}

void oledWriteChar1x(char letter, unsigned char page, unsigned char column)
{
    BYTE i, j;

    letter -= ' ';                  // Adjust character to table that starts at 0x20
    // Convert all non-printable characters to a space
    if(letter >= sizeof(g_pucFont)/sizeof(g_pucFont[0]))
        letter = 0;

    oledWriteCommand(page);
    column += OFFSET;
    oledWriteCommand(0x00+(column&0x0F));
    oledWriteCommand(0x10+((column>>4)&0x0F));

    // Writes a 5x8 character from the font table
    oledD_C = 1;
    Nop();
    oledCS = 0;
    for(j = 0; j < 5u; j++)
    {
        i = g_pucFont[letter][j];   // Write column j
        OutputByteToPins(i);
        Nop();
        oledWR = 0;
        Nop();
        oledWR = 1;
    }


    Nop();
    OutputByteToPins(0x00);         // Write 1 column for buffer to next character
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;
    Nop();
    oledCS = 1;
    return;
}

void oledWriteChar2x(char letter, unsigned char page, unsigned char column)
{
    unsigned char _letter;

    letter -= ' ';
    // Convert all non-printable characters to a space
    if(letter >= sizeof(g_pucFont)/sizeof(g_pucFont[0]))
        letter = 0;

    oledWriteCommand(page);
    column += OFFSET;
    oledWriteCommand(0x00+(column&0x0F));
    oledWriteCommand(0x10+((column>>4)&0x0F));

    oledD_C = 1;
    Nop();
    oledCS = 0;
    _letter = Convert1xto2x(0,g_pucFont[letter][0]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(0,g_pucFont[letter][1]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(0,g_pucFont[letter][2]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(0,g_pucFont[letter][3]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(0,g_pucFont[letter][4]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    OutputByteToPins(0x00);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;
    Nop();
    oledCS = 1;

    oledWriteCommand(page+1);
    oledWriteCommand(0x00+(column&0x0F));
    oledWriteCommand(0x10+((column>>4)&0x0F));

    oledD_C = 1;
    Nop();
    oledCS = 0;
    Nop();
    _letter = Convert1xto2x(1,g_pucFont[letter][0]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(1,g_pucFont[letter][1]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(1,g_pucFont[letter][2]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(1,g_pucFont[letter][3]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    _letter = Convert1xto2x(1,g_pucFont[letter][4]);
    OutputByteToPins(_letter);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;

    Nop();
    OutputByteToPins(0x00);
    Nop();
    oledWR = 0;
    Nop();
    oledWR = 1;
    Nop();
    oledCS = 1;

    return;
}

void oledWriteCommand(unsigned char cmd)
{
    oledD_C = 0;                    // Enable commands
    Nop();
    oledCS = 0;                     // Enable display
    Nop();
    OutputByteToPins(cmd);
    Nop();
    oledWR = 0;                     // Enable writes
    Nop();
    oledWR = 1;                     // Disable writes
    Nop();
    oledCS = 1;                     // Disable display
    Delay1KTCYx(1);                 // Delay for 7,000 cycles or 1.12ms
    return;
}

//******************************************************************************
//******************************************************************************
// Section: Internal Functions
//******************************************************************************
//******************************************************************************

unsigned char Convert1xto2x(unsigned char uplow, unsigned char byte)
{
    unsigned char result;

    result = 0;
    if(uplow)
    {
        if(byte&0x10)
        {
            result |= 0x01;
            result |= 0x02;
        }
        if(byte&0x20)
        {
            result |= 0x04;
            result |= 0x08;
        }
        if(byte&0x40)
        {
            result |= 0x10;
            result |= 0x20;
        }
        if(byte&0x80)
        {
            result |= 0x40;
            result |= 0x80;
        }
    }
    else
    {
        if(byte&0x01)
        {
            result |= 0x01;
            result |= 0x02;
        }
        if(byte&0x02)
        {
            result |= 0x04;
            result |= 0x08;
        }
        if(byte&0x04)
        {
            result |= 0x10;
            result |= 0x20;
        }
        if(byte&0x08)
        {
            result |= 0x40;
            result |= 0x80;
        }
    }
    return result;
}


//////////////////////////////////////
//////////////////////////////////////
// OLED ROM CONSTANT DATA ////////////
//////////////////////////////////////
//////////////////////////////////////
ROM BYTE g_pucFont[95][5] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00 }, // " " 0x20
    { 0x00, 0x00, 0x4f, 0x00, 0x00 }, // !   0x21
    { 0x00, 0x07, 0x00, 0x07, 0x00 }, // "   0x22
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 }, // #   0x23
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 }, // $   0x24
    { 0x23, 0x13, 0x08, 0x64, 0x62 }, // %   0x25
    { 0x36, 0x49, 0x55, 0x22, 0x50 }, // &   0x26
    { 0x00, 0x05, 0x03, 0x00, 0x00 }, // '   0x27
    { 0x00, 0x1c, 0x22, 0x41, 0x00 }, // (   0x28
    { 0x00, 0x41, 0x22, 0x1c, 0x00 }, // )   0x29
    { 0x14, 0x08, 0x3e, 0x08, 0x14 }, // *   0x2A
    { 0x08, 0x08, 0x3e, 0x08, 0x08 }, // +   0x2B
    { 0x00, 0x50, 0x30, 0x00, 0x00 }, // ,   0x2C
    { 0x08, 0x08, 0x08, 0x08, 0x08 }, // -   0x2D
    { 0x00, 0x60, 0x60, 0x00, 0x00 }, // .   0x2E
    { 0x20, 0x10, 0x08, 0x04, 0x02 }, // /   0x2F
    { 0x3e, 0x51, 0x49, 0x45, 0x3e }, // 0   0x30
    { 0x00, 0x42, 0x7f, 0x40, 0x00 }, // 1   0x31
    { 0x42, 0x61, 0x51, 0x49, 0x46 }, // 2   0x32
    { 0x21, 0x41, 0x45, 0x4b, 0x31 }, // 3   0x33
    { 0x18, 0x14, 0x12, 0x7f, 0x10 }, // 4   0x34
    { 0x27, 0x45, 0x45, 0x45, 0x39 }, // 5   0x35
    { 0x3c, 0x4a, 0x49, 0x49, 0x30 }, // 6   0x36
    { 0x01, 0x71, 0x09, 0x05, 0x03 }, // 7   0x37
    { 0x36, 0x49, 0x49, 0x49, 0x36 }, // 8   0x38
    { 0x06, 0x49, 0x49, 0x29, 0x1e }, // 9   0x39
    { 0x00, 0x36, 0x36, 0x00, 0x00 }, // :   0x3A
    { 0x00, 0x56, 0x36, 0x00, 0x00 }, // ;   0x3B
    { 0x08, 0x14, 0x22, 0x41, 0x00 }, // <   0x3C
    { 0x14, 0x14, 0x14, 0x14, 0x14 }, // =   0x3D
    { 0x00, 0x41, 0x22, 0x14, 0x08 }, // >   0x3E
    { 0x02, 0x01, 0x51, 0x09, 0x06 }, // ?   0x3F
    { 0x32, 0x49, 0x79, 0x41, 0x3e }, // @   0x40
    { 0x7e, 0x11, 0x11, 0x11, 0x7e }, // A   0x41
    { 0x7f, 0x49, 0x49, 0x49, 0x36 }, // B   0x42
    { 0x3e, 0x41, 0x41, 0x41, 0x22 }, // C   0x43
    { 0x7f, 0x41, 0x41, 0x22, 0x1c }, // D   0x44
    { 0x7f, 0x49, 0x49, 0x49, 0x41 }, // E   0x45
    { 0x7f, 0x09, 0x09, 0x09, 0x01 }, // F   0x46
    { 0x3e, 0x41, 0x49, 0x49, 0x7a }, // G   0x47
    { 0x7f, 0x08, 0x08, 0x08, 0x7f }, // H   0x48
    { 0x00, 0x41, 0x7f, 0x41, 0x00 }, // I   0x49
    { 0x20, 0x40, 0x41, 0x3f, 0x01 }, // J   0x4A
    { 0x7f, 0x08, 0x14, 0x22, 0x41 }, // K   0x4B
    { 0x7f, 0x40, 0x40, 0x40, 0x40 }, // L   0x4C
    { 0x7f, 0x02, 0x0c, 0x02, 0x7f }, // M   0x4D
    { 0x7f, 0x04, 0x08, 0x10, 0x7f }, // N   0x4E
    { 0x3e, 0x41, 0x41, 0x41, 0x3e }, // O   0x4F
    { 0x7f, 0x09, 0x09, 0x09, 0x06 }, // P   0X50
    { 0x3e, 0x41, 0x51, 0x21, 0x5e }, // Q   0X51
    { 0x7f, 0x09, 0x19, 0x29, 0x46 }, // R   0X52
    { 0x46, 0x49, 0x49, 0x49, 0x31 }, // S   0X53
    { 0x01, 0x01, 0x7f, 0x01, 0x01 }, // T   0X54
    { 0x3f, 0x40, 0x40, 0x40, 0x3f }, // U   0X55
    { 0x1f, 0x20, 0x40, 0x20, 0x1f }, // V   0X56
    { 0x3f, 0x40, 0x38, 0x40, 0x3f }, // W   0X57
    { 0x63, 0x14, 0x08, 0x14, 0x63 }, // X   0X58
    { 0x07, 0x08, 0x70, 0x08, 0x07 }, // Y   0X59
    { 0x61, 0x51, 0x49, 0x45, 0x43 }, // Z   0X5A
    { 0x00, 0x7f, 0x41, 0x41, 0x00 }, // [   0X5B
    { 0x02, 0x04, 0x08, 0x10, 0x20 }, // "\" 0X5C
    { 0x00, 0x41, 0x41, 0x7f, 0x00 }, // ]   0X5D
    { 0x04, 0x02, 0x01, 0x02, 0x04 }, // ^   0X5E
    { 0x40, 0x40, 0x40, 0x40, 0x40 }, // _   0X5F
    { 0x00, 0x01, 0x02, 0x04, 0x00 }, // `   0X60
    { 0x20, 0x54, 0x54, 0x54, 0x78 }, // a   0X61
    { 0x7f, 0x48, 0x44, 0x44, 0x38 }, // b   0X62
    { 0x38, 0x44, 0x44, 0x44, 0x20 }, // c   0X63
    { 0x38, 0x44, 0x44, 0x48, 0x7f }, // d   0X64
    { 0x38, 0x54, 0x54, 0x54, 0x18 }, // e   0X65
    { 0x08, 0x7e, 0x09, 0x01, 0x02 }, // f   0X66
    { 0x0c, 0x52, 0x52, 0x52, 0x3e }, // g   0X67
    { 0x7f, 0x08, 0x04, 0x04, 0x78 }, // h   0X68
    { 0x00, 0x44, 0x7d, 0x40, 0x00 }, // i   0X69
    { 0x20, 0x40, 0x44, 0x3d, 0x00 }, // j   0X6A
    { 0x7f, 0x10, 0x28, 0x44, 0x00 }, // k   0X6B
    { 0x00, 0x41, 0x7f, 0x40, 0x00 }, // l   0X6C
    { 0x7c, 0x04, 0x18, 0x04, 0x78 }, // m   0X6D
    { 0x7c, 0x08, 0x04, 0x04, 0x78 }, // n   0X6E
    { 0x38, 0x44, 0x44, 0x44, 0x38 }, // o   0X6F
    { 0x7c, 0x14, 0x14, 0x14, 0x08 }, // p   0X70
    { 0x08, 0x14, 0x14, 0x18, 0x7c }, // q   0X71
    { 0x7c, 0x08, 0x04, 0x04, 0x08 }, // r   0X72
    { 0x48, 0x54, 0x54, 0x54, 0x20 }, // s   0X73
    { 0x04, 0x3f, 0x44, 0x40, 0x20 }, // t   0X74
    { 0x3c, 0x40, 0x40, 0x20, 0x7c }, // u   0X75
    { 0x1c, 0x20, 0x40, 0x20, 0x1c }, // v   0X76
    { 0x3c, 0x40, 0x30, 0x40, 0x3c }, // w   0X77
    { 0x44, 0x28, 0x10, 0x28, 0x44 }, // x   0X78
    { 0x0c, 0x50, 0x50, 0x50, 0x3c }, // y   0X79
    { 0x44, 0x64, 0x54, 0x4c, 0x44 }, // z   0X7A
    { 0x00, 0x08, 0x36, 0x41, 0x00 }, // {   0X7B
    { 0x00, 0x00, 0x7f, 0x00, 0x00 }, // |   0X7C
    { 0x00, 0x41, 0x36, 0x08, 0x00 }, // }   0X7D
    { 0x02, 0x01, 0x02, 0x04, 0x02 }, // ~   0X7E
};


// Start up splash screen
//   M Microchip
// Internet Radio
ROM BYTE Microchip[1024] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
    0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xf8,0xfc,0xfe,0xbf,0x1f,0x07,
    0x07,0x07,0x1f,0x3f,0xff,0xff,0x1f,0x0f,0x07,0x07,0x0f,0x3c,0x79,0xe0,0xc2,0x00,
    0x00,0x00,0x00,0x00,0x00,0xe0,0xf8,0xf8,0xe0,0x80,0x00,0x00,0x80,0xe0,0xf8,0xf8,
    0xf0,0x00,0x00,0xc0,0xc0,0x00,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0xc0,
    0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
    0x80,0x00,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0xc0,0xc0,0x00,0x00,0x00,
    0x00,0xc0,0xc0,0x00,0x00,0xc0,0xc0,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x0f,0x03,0x01,0x01,0x83,0xce,0xfc,
    0xf0,0xe0,0x80,0x00,0x00,0x03,0x07,0x9e,0xf8,0xf0,0xc0,0x00,0x00,0x01,0x03,0x0f,
    0x1c,0x00,0x00,0x00,0x40,0x7f,0x7f,0x00,0x07,0x1f,0x7c,0x7c,0x3f,0x07,0x00,0x7f,
    0x7f,0x40,0x00,0x7f,0x7f,0x00,0x3f,0x7f,0x61,0x60,0x60,0x60,0x60,0x60,0x00,0x7f,
    0x7f,0x18,0x18,0x18,0x18,0x7f,0x7f,0x00,0x00,0x7f,0x73,0x60,0x60,0x60,0x61,0x7f,
    0x7f,0x00,0x3f,0x7f,0x61,0x60,0x60,0x60,0x61,0x61,0x00,0x7f,0x7f,0x0e,0x0e,0x0e,
    0x0e,0x7f,0x7f,0x00,0x00,0x7f,0x7f,0x00,0x7f,0x7f,0x18,0x18,0x18,0x18,0x1f,0x0f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x0f,0x1f,0x1f,
    0x1f,0x3f,0x3f,0x3f,0x3c,0x3e,0x3f,0x3f,0x1f,0x1f,0x1f,0x0f,0x06,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x01,0xf9,0xff,0x0f,0x01,0x01,0x00,0x00,0xf8,0xf8,0xe0,
    0x30,0x18,0x08,0xf8,0xf8,0x80,0xc0,0x74,0xf4,0xfe,0x0f,0x85,0x84,0xe4,0xf4,0x5c,
    0x68,0x28,0xb8,0x98,0xc0,0x60,0xe0,0xf8,0x78,0x30,0x18,0x08,0x08,0x00,0xf8,0xf8,
    0xe0,0x30,0x18,0x08,0xf8,0xf8,0x80,0xc0,0xf0,0xf0,0x58,0x68,0x28,0xb8,0x98,0xc0,
    0x64,0xf4,0xfe,0x0f,0x85,0x84,0x04,0x04,0x04,0x00,0x00,0x04,0xc6,0xff,0x3f,0x31,
    0xf1,0xd9,0x8f,0x06,0x00,0x00,0xe0,0xf0,0x18,0x88,0xc8,0xf8,0xf8,0x08,0x80,0xc0,
    0x60,0xe0,0xf0,0x18,0x88,0xc8,0xf8,0xfe,0x0f,0x81,0xc0,0x60,0xe0,0xfa,0x3a,0x83,
    0xc1,0xe0,0xf0,0x98,0x18,0x8c,0xcc,0xf8,0x70,0x10,0x10,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,
    0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,
    0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
    0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
    0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x00,
    0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,
    0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,
    0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


